; Example PICA200 geometry shader
.gsh point c0

; Uniforms
.fvec projection[4]
.fvec tint
; .fvec depthinfo

; Constants
.constf myconst(0.0, 1.0, -1.0, 0.5)
.constf myconst20(20.0, 20.0, 20.0, 20.0)
.alias  zeros myconst.xxxx ; Vector full of zeros
.alias  ones  myconst.yyyy ; Vector full of ones
.alias  half  myconst.wwww

; Outputs - this time the type *is* used
.out outpos position
.out outclr color

; Inputs: we will receive the following inputs:
; v0: top left of the sprite
.in inpos v0
.in inwhtc v1

.entry gmain
.proc gmain
	mov r5, myconst20

	; Emit the first triangle
	mov r0, v0
	mov r0.z, zeros.z
	mov r1, v0
	mov r1.z, zeros.z
	add r1.x, r1.x, inwhtc.x
	mov r2, v0
	mov r2.z, zeros.z
	add r2.y, r2.y, inwhtc.y
	call emit_triangle

	; ; Emit the second triangle
	; mov r0, v0
	; add r0.x, r0.x, v1.x
	; mov r1, v0
	; add r1.xy, r1.xy, v1.xy
	; mov r2, v0
	; add r2.y, r2.y, v1.y
	; call emit_triangle

	; We're finished
	end
.end

.proc emit_triangle
	; Emit the first vertex
	setemit 0
	mov r8, r0
	call process_vertex
	emit

	; Emit the second vertex
	setemit 1
	mov r8, r1
	call process_vertex
	emit

	; Emit the third vertex and finish the primitive
	setemit 2, prim
	mov r8, r2
	call process_vertex
	emit
.end

; Subroutine
; Inputs:
;   r8: vertex position
.proc process_vertex
	mov r8.w, ones.w
	; outpos = projectionMatrix * r8
	dp4 outpos.x, projection[0], r8
	dp4 outpos.y, projection[1], r8
	dp4 outpos.z, projection[2], r8
	dp4 outpos.w, projection[3], r8

	; outclr = r9
	mov outclr, tint
.end